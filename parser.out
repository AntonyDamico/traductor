Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN
    COMMA
    FUNCTION
    PROMPT

Grammar

Rule 0     S' -> S
Rule 1     S -> statement S
Rule 2     S -> statement END_LINE S
Rule 3     S -> statement END_LINE
Rule 4     S -> statement
Rule 5     statement -> command
Rule 6     statement -> declarations
Rule 7     statement -> expr
Rule 8     declarations -> VAR ID ASSIGN expr
Rule 9     declarations -> VAR ID ASSIGN relexpr
Rule 10    declarations -> VAR ID
Rule 11    command -> WRITE LPAREN expr RPAREN
Rule 12    command -> WRITE LPAREN relexpr RPAREN
Rule 13    command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
Rule 14    command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
Rule 15    command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
Rule 16    command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
Rule 17    command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
Rule 18    command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
Rule 19    expr -> expr PLUS expr
Rule 20    expr -> expr MINUS expr
Rule 21    expr -> expr TIMES expr
Rule 22    expr -> expr DIVIDE expr
Rule 23    expr -> expr MOD expr
Rule 24    expr -> expr INCREMENT
Rule 25    expr -> expr DECREMENT
Rule 26    expr -> ID ASSIGN expr
Rule 27    expr -> NUMBER
Rule 28    expr -> STRINGS
Rule 29    expr -> ID
Rule 30    expr -> TRUE
Rule 31    expr -> FALSE
Rule 32    relexpr -> expr LT expr
Rule 33    relexpr -> expr LE expr
Rule 34    relexpr -> expr GT expr
Rule 35    relexpr -> expr GE expr
Rule 36    relexpr -> expr EQUALS expr
Rule 37    relexpr -> expr NE expr
Rule 38    relexpr -> NOT expr
Rule 39    relexprgroup -> relexpr AND relexprgroup
Rule 40    relexprgroup -> relexpr OR relexprgroup
Rule 41    relexprgroup -> relexpr
Rule 42    relexprgroup -> expr

Terminals, with rules where they appear

AND                  : 39
ASSIGN               : 8 9 26
COMMA                : 
DECREMENT            : 25
DIVIDE               : 22
ELSE                 : 17 18
END_LINE             : 2 3 15 15
EQUALS               : 36
FALSE                : 31
FOR                  : 15
FUNCTION             : 
GE                   : 35
GT                   : 34
ID                   : 8 9 10 26 29
IF                   : 16 17 18
INCREMENT            : 24
LBRACKET             : 13 14 15 16 17 18 18
LE                   : 33
LPAREN               : 11 12 13 14 15 16 17 18
LT                   : 32
MINUS                : 20
MOD                  : 23
NE                   : 37
NOT                  : 38
NUMBER               : 27
OR                   : 40
PLUS                 : 19
PROMPT               : 
RBRACKET             : 13 14 15 16 17 18 18
RETURN               : 
RPAREN               : 11 12 13 14 15 16 17 18
STRINGS              : 28
TIMES                : 21
TRUE                 : 30
VAR                  : 8 9 10
WHILE                : 13 14
WRITE                : 11 12
error                : 

Nonterminals, with rules where they appear

S                    : 1 2 13 14 15 16 17 18 18 0
command              : 5 17
declarations         : 6 15
expr                 : 7 8 11 13 15 19 19 20 20 21 21 22 22 23 23 24 25 26 32 32 33 33 34 34 35 35 36 36 37 37 38 42
relexpr              : 9 12 14 15 39 40 41
relexprgroup         : 16 17 18 39 40
statement            : 1 2 3 4

Parsing method: LALR

state 0

    (0) S' -> . S
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 8
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 1

    (27) expr -> NUMBER .

    PLUS            reduce using rule 27 (expr -> NUMBER .)
    MINUS           reduce using rule 27 (expr -> NUMBER .)
    TIMES           reduce using rule 27 (expr -> NUMBER .)
    DIVIDE          reduce using rule 27 (expr -> NUMBER .)
    MOD             reduce using rule 27 (expr -> NUMBER .)
    INCREMENT       reduce using rule 27 (expr -> NUMBER .)
    DECREMENT       reduce using rule 27 (expr -> NUMBER .)
    END_LINE        reduce using rule 27 (expr -> NUMBER .)
    WRITE           reduce using rule 27 (expr -> NUMBER .)
    WHILE           reduce using rule 27 (expr -> NUMBER .)
    FOR             reduce using rule 27 (expr -> NUMBER .)
    IF              reduce using rule 27 (expr -> NUMBER .)
    VAR             reduce using rule 27 (expr -> NUMBER .)
    ID              reduce using rule 27 (expr -> NUMBER .)
    NUMBER          reduce using rule 27 (expr -> NUMBER .)
    STRINGS         reduce using rule 27 (expr -> NUMBER .)
    TRUE            reduce using rule 27 (expr -> NUMBER .)
    FALSE           reduce using rule 27 (expr -> NUMBER .)
    RBRACKET        reduce using rule 27 (expr -> NUMBER .)
    LT              reduce using rule 27 (expr -> NUMBER .)
    LE              reduce using rule 27 (expr -> NUMBER .)
    GT              reduce using rule 27 (expr -> NUMBER .)
    GE              reduce using rule 27 (expr -> NUMBER .)
    EQUALS          reduce using rule 27 (expr -> NUMBER .)
    NE              reduce using rule 27 (expr -> NUMBER .)
    $end            reduce using rule 27 (expr -> NUMBER .)
    RPAREN          reduce using rule 27 (expr -> NUMBER .)
    AND             reduce using rule 27 (expr -> NUMBER .)
    OR              reduce using rule 27 (expr -> NUMBER .)


state 2

    (13) command -> WHILE . LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> WHILE . LPAREN relexpr RPAREN LBRACKET S RBRACKET

    LPAREN          shift and go to state 16


state 3

    (30) expr -> TRUE .

    PLUS            reduce using rule 30 (expr -> TRUE .)
    MINUS           reduce using rule 30 (expr -> TRUE .)
    TIMES           reduce using rule 30 (expr -> TRUE .)
    DIVIDE          reduce using rule 30 (expr -> TRUE .)
    MOD             reduce using rule 30 (expr -> TRUE .)
    INCREMENT       reduce using rule 30 (expr -> TRUE .)
    DECREMENT       reduce using rule 30 (expr -> TRUE .)
    END_LINE        reduce using rule 30 (expr -> TRUE .)
    WRITE           reduce using rule 30 (expr -> TRUE .)
    WHILE           reduce using rule 30 (expr -> TRUE .)
    FOR             reduce using rule 30 (expr -> TRUE .)
    IF              reduce using rule 30 (expr -> TRUE .)
    VAR             reduce using rule 30 (expr -> TRUE .)
    ID              reduce using rule 30 (expr -> TRUE .)
    NUMBER          reduce using rule 30 (expr -> TRUE .)
    STRINGS         reduce using rule 30 (expr -> TRUE .)
    TRUE            reduce using rule 30 (expr -> TRUE .)
    FALSE           reduce using rule 30 (expr -> TRUE .)
    RBRACKET        reduce using rule 30 (expr -> TRUE .)
    LT              reduce using rule 30 (expr -> TRUE .)
    LE              reduce using rule 30 (expr -> TRUE .)
    GT              reduce using rule 30 (expr -> TRUE .)
    GE              reduce using rule 30 (expr -> TRUE .)
    EQUALS          reduce using rule 30 (expr -> TRUE .)
    NE              reduce using rule 30 (expr -> TRUE .)
    $end            reduce using rule 30 (expr -> TRUE .)
    RPAREN          reduce using rule 30 (expr -> TRUE .)
    AND             reduce using rule 30 (expr -> TRUE .)
    OR              reduce using rule 30 (expr -> TRUE .)


state 4

    (28) expr -> STRINGS .

    PLUS            reduce using rule 28 (expr -> STRINGS .)
    MINUS           reduce using rule 28 (expr -> STRINGS .)
    TIMES           reduce using rule 28 (expr -> STRINGS .)
    DIVIDE          reduce using rule 28 (expr -> STRINGS .)
    MOD             reduce using rule 28 (expr -> STRINGS .)
    INCREMENT       reduce using rule 28 (expr -> STRINGS .)
    DECREMENT       reduce using rule 28 (expr -> STRINGS .)
    END_LINE        reduce using rule 28 (expr -> STRINGS .)
    WRITE           reduce using rule 28 (expr -> STRINGS .)
    WHILE           reduce using rule 28 (expr -> STRINGS .)
    FOR             reduce using rule 28 (expr -> STRINGS .)
    IF              reduce using rule 28 (expr -> STRINGS .)
    VAR             reduce using rule 28 (expr -> STRINGS .)
    ID              reduce using rule 28 (expr -> STRINGS .)
    NUMBER          reduce using rule 28 (expr -> STRINGS .)
    STRINGS         reduce using rule 28 (expr -> STRINGS .)
    TRUE            reduce using rule 28 (expr -> STRINGS .)
    FALSE           reduce using rule 28 (expr -> STRINGS .)
    RBRACKET        reduce using rule 28 (expr -> STRINGS .)
    LT              reduce using rule 28 (expr -> STRINGS .)
    LE              reduce using rule 28 (expr -> STRINGS .)
    GT              reduce using rule 28 (expr -> STRINGS .)
    GE              reduce using rule 28 (expr -> STRINGS .)
    EQUALS          reduce using rule 28 (expr -> STRINGS .)
    NE              reduce using rule 28 (expr -> STRINGS .)
    $end            reduce using rule 28 (expr -> STRINGS .)
    RPAREN          reduce using rule 28 (expr -> STRINGS .)
    AND             reduce using rule 28 (expr -> STRINGS .)
    OR              reduce using rule 28 (expr -> STRINGS .)


state 5

    (1) S -> statement . S
    (2) S -> statement . END_LINE S
    (3) S -> statement . END_LINE
    (4) S -> statement .
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    END_LINE        shift and go to state 18
    RBRACKET        reduce using rule 4 (S -> statement .)
    $end            reduce using rule 4 (S -> statement .)
    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 17
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 6

    (15) command -> FOR . LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET

    LPAREN          shift and go to state 19


state 7

    (11) command -> WRITE . LPAREN expr RPAREN
    (12) command -> WRITE . LPAREN relexpr RPAREN

    LPAREN          shift and go to state 20


state 8

    (0) S' -> S .



state 9

    (8) declarations -> VAR . ID ASSIGN expr
    (9) declarations -> VAR . ID ASSIGN relexpr
    (10) declarations -> VAR . ID

    ID              shift and go to state 21


state 10

    (26) expr -> ID . ASSIGN expr
    (29) expr -> ID .

    ASSIGN          shift and go to state 22
    PLUS            reduce using rule 29 (expr -> ID .)
    MINUS           reduce using rule 29 (expr -> ID .)
    TIMES           reduce using rule 29 (expr -> ID .)
    DIVIDE          reduce using rule 29 (expr -> ID .)
    MOD             reduce using rule 29 (expr -> ID .)
    INCREMENT       reduce using rule 29 (expr -> ID .)
    DECREMENT       reduce using rule 29 (expr -> ID .)
    END_LINE        reduce using rule 29 (expr -> ID .)
    WRITE           reduce using rule 29 (expr -> ID .)
    WHILE           reduce using rule 29 (expr -> ID .)
    FOR             reduce using rule 29 (expr -> ID .)
    IF              reduce using rule 29 (expr -> ID .)
    VAR             reduce using rule 29 (expr -> ID .)
    ID              reduce using rule 29 (expr -> ID .)
    NUMBER          reduce using rule 29 (expr -> ID .)
    STRINGS         reduce using rule 29 (expr -> ID .)
    TRUE            reduce using rule 29 (expr -> ID .)
    FALSE           reduce using rule 29 (expr -> ID .)
    RBRACKET        reduce using rule 29 (expr -> ID .)
    LT              reduce using rule 29 (expr -> ID .)
    LE              reduce using rule 29 (expr -> ID .)
    GT              reduce using rule 29 (expr -> ID .)
    GE              reduce using rule 29 (expr -> ID .)
    EQUALS          reduce using rule 29 (expr -> ID .)
    NE              reduce using rule 29 (expr -> ID .)
    $end            reduce using rule 29 (expr -> ID .)
    RPAREN          reduce using rule 29 (expr -> ID .)
    AND             reduce using rule 29 (expr -> ID .)
    OR              reduce using rule 29 (expr -> ID .)


state 11

    (16) command -> IF . LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> IF . LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> IF . LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET

    LPAREN          shift and go to state 23


state 12

    (31) expr -> FALSE .

    PLUS            reduce using rule 31 (expr -> FALSE .)
    MINUS           reduce using rule 31 (expr -> FALSE .)
    TIMES           reduce using rule 31 (expr -> FALSE .)
    DIVIDE          reduce using rule 31 (expr -> FALSE .)
    MOD             reduce using rule 31 (expr -> FALSE .)
    INCREMENT       reduce using rule 31 (expr -> FALSE .)
    DECREMENT       reduce using rule 31 (expr -> FALSE .)
    END_LINE        reduce using rule 31 (expr -> FALSE .)
    WRITE           reduce using rule 31 (expr -> FALSE .)
    WHILE           reduce using rule 31 (expr -> FALSE .)
    FOR             reduce using rule 31 (expr -> FALSE .)
    IF              reduce using rule 31 (expr -> FALSE .)
    VAR             reduce using rule 31 (expr -> FALSE .)
    ID              reduce using rule 31 (expr -> FALSE .)
    NUMBER          reduce using rule 31 (expr -> FALSE .)
    STRINGS         reduce using rule 31 (expr -> FALSE .)
    TRUE            reduce using rule 31 (expr -> FALSE .)
    FALSE           reduce using rule 31 (expr -> FALSE .)
    RBRACKET        reduce using rule 31 (expr -> FALSE .)
    LT              reduce using rule 31 (expr -> FALSE .)
    LE              reduce using rule 31 (expr -> FALSE .)
    GT              reduce using rule 31 (expr -> FALSE .)
    GE              reduce using rule 31 (expr -> FALSE .)
    EQUALS          reduce using rule 31 (expr -> FALSE .)
    NE              reduce using rule 31 (expr -> FALSE .)
    $end            reduce using rule 31 (expr -> FALSE .)
    RPAREN          reduce using rule 31 (expr -> FALSE .)
    AND             reduce using rule 31 (expr -> FALSE .)
    OR              reduce using rule 31 (expr -> FALSE .)


state 13

    (7) statement -> expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    END_LINE        reduce using rule 7 (statement -> expr .)
    WRITE           reduce using rule 7 (statement -> expr .)
    WHILE           reduce using rule 7 (statement -> expr .)
    FOR             reduce using rule 7 (statement -> expr .)
    IF              reduce using rule 7 (statement -> expr .)
    VAR             reduce using rule 7 (statement -> expr .)
    ID              reduce using rule 7 (statement -> expr .)
    NUMBER          reduce using rule 7 (statement -> expr .)
    STRINGS         reduce using rule 7 (statement -> expr .)
    TRUE            reduce using rule 7 (statement -> expr .)
    FALSE           reduce using rule 7 (statement -> expr .)
    RBRACKET        reduce using rule 7 (statement -> expr .)
    $end            reduce using rule 7 (statement -> expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 14

    (6) statement -> declarations .

    END_LINE        reduce using rule 6 (statement -> declarations .)
    WRITE           reduce using rule 6 (statement -> declarations .)
    WHILE           reduce using rule 6 (statement -> declarations .)
    FOR             reduce using rule 6 (statement -> declarations .)
    IF              reduce using rule 6 (statement -> declarations .)
    VAR             reduce using rule 6 (statement -> declarations .)
    ID              reduce using rule 6 (statement -> declarations .)
    NUMBER          reduce using rule 6 (statement -> declarations .)
    STRINGS         reduce using rule 6 (statement -> declarations .)
    TRUE            reduce using rule 6 (statement -> declarations .)
    FALSE           reduce using rule 6 (statement -> declarations .)
    RBRACKET        reduce using rule 6 (statement -> declarations .)
    $end            reduce using rule 6 (statement -> declarations .)


state 15

    (5) statement -> command .

    END_LINE        reduce using rule 5 (statement -> command .)
    WRITE           reduce using rule 5 (statement -> command .)
    WHILE           reduce using rule 5 (statement -> command .)
    FOR             reduce using rule 5 (statement -> command .)
    IF              reduce using rule 5 (statement -> command .)
    VAR             reduce using rule 5 (statement -> command .)
    ID              reduce using rule 5 (statement -> command .)
    NUMBER          reduce using rule 5 (statement -> command .)
    STRINGS         reduce using rule 5 (statement -> command .)
    TRUE            reduce using rule 5 (statement -> command .)
    FALSE           reduce using rule 5 (statement -> command .)
    RBRACKET        reduce using rule 5 (statement -> command .)
    $end            reduce using rule 5 (statement -> command .)


state 16

    (13) command -> WHILE LPAREN . expr RPAREN LBRACKET S RBRACKET
    (14) command -> WHILE LPAREN . relexpr RPAREN LBRACKET S RBRACKET
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12
    NOT             shift and go to state 33

    expr                           shift and go to state 32
    relexpr                        shift and go to state 31

state 17

    (1) S -> statement S .

    RBRACKET        reduce using rule 1 (S -> statement S .)
    $end            reduce using rule 1 (S -> statement S .)


state 18

    (2) S -> statement END_LINE . S
    (3) S -> statement END_LINE .
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    RBRACKET        reduce using rule 3 (S -> statement END_LINE .)
    $end            reduce using rule 3 (S -> statement END_LINE .)
    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 34
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 19

    (15) command -> FOR LPAREN . declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID

    VAR             shift and go to state 9

    declarations                   shift and go to state 35

state 20

    (11) command -> WRITE LPAREN . expr RPAREN
    (12) command -> WRITE LPAREN . relexpr RPAREN
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12
    NOT             shift and go to state 33

    expr                           shift and go to state 37
    relexpr                        shift and go to state 36

state 21

    (8) declarations -> VAR ID . ASSIGN expr
    (9) declarations -> VAR ID . ASSIGN relexpr
    (10) declarations -> VAR ID .

    ASSIGN          shift and go to state 38
    END_LINE        reduce using rule 10 (declarations -> VAR ID .)
    WRITE           reduce using rule 10 (declarations -> VAR ID .)
    WHILE           reduce using rule 10 (declarations -> VAR ID .)
    FOR             reduce using rule 10 (declarations -> VAR ID .)
    IF              reduce using rule 10 (declarations -> VAR ID .)
    VAR             reduce using rule 10 (declarations -> VAR ID .)
    ID              reduce using rule 10 (declarations -> VAR ID .)
    NUMBER          reduce using rule 10 (declarations -> VAR ID .)
    STRINGS         reduce using rule 10 (declarations -> VAR ID .)
    TRUE            reduce using rule 10 (declarations -> VAR ID .)
    FALSE           reduce using rule 10 (declarations -> VAR ID .)
    RBRACKET        reduce using rule 10 (declarations -> VAR ID .)
    $end            reduce using rule 10 (declarations -> VAR ID .)


state 22

    (26) expr -> ID ASSIGN . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 39

state 23

    (16) command -> IF LPAREN . relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> IF LPAREN . relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> IF LPAREN . relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (39) relexprgroup -> . relexpr AND relexprgroup
    (40) relexprgroup -> . relexpr OR relexprgroup
    (41) relexprgroup -> . relexpr
    (42) relexprgroup -> . expr
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    NOT             shift and go to state 33
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    relexprgroup                   shift and go to state 40
    relexpr                        shift and go to state 41
    expr                           shift and go to state 42

state 24

    (22) expr -> expr DIVIDE . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 43

state 25

    (21) expr -> expr TIMES . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 44

state 26

    (19) expr -> expr PLUS . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 45

state 27

    (24) expr -> expr INCREMENT .

    PLUS            reduce using rule 24 (expr -> expr INCREMENT .)
    MINUS           reduce using rule 24 (expr -> expr INCREMENT .)
    TIMES           reduce using rule 24 (expr -> expr INCREMENT .)
    DIVIDE          reduce using rule 24 (expr -> expr INCREMENT .)
    MOD             reduce using rule 24 (expr -> expr INCREMENT .)
    INCREMENT       reduce using rule 24 (expr -> expr INCREMENT .)
    DECREMENT       reduce using rule 24 (expr -> expr INCREMENT .)
    END_LINE        reduce using rule 24 (expr -> expr INCREMENT .)
    WRITE           reduce using rule 24 (expr -> expr INCREMENT .)
    WHILE           reduce using rule 24 (expr -> expr INCREMENT .)
    FOR             reduce using rule 24 (expr -> expr INCREMENT .)
    IF              reduce using rule 24 (expr -> expr INCREMENT .)
    VAR             reduce using rule 24 (expr -> expr INCREMENT .)
    ID              reduce using rule 24 (expr -> expr INCREMENT .)
    NUMBER          reduce using rule 24 (expr -> expr INCREMENT .)
    STRINGS         reduce using rule 24 (expr -> expr INCREMENT .)
    TRUE            reduce using rule 24 (expr -> expr INCREMENT .)
    FALSE           reduce using rule 24 (expr -> expr INCREMENT .)
    RBRACKET        reduce using rule 24 (expr -> expr INCREMENT .)
    LT              reduce using rule 24 (expr -> expr INCREMENT .)
    LE              reduce using rule 24 (expr -> expr INCREMENT .)
    GT              reduce using rule 24 (expr -> expr INCREMENT .)
    GE              reduce using rule 24 (expr -> expr INCREMENT .)
    EQUALS          reduce using rule 24 (expr -> expr INCREMENT .)
    NE              reduce using rule 24 (expr -> expr INCREMENT .)
    $end            reduce using rule 24 (expr -> expr INCREMENT .)
    RPAREN          reduce using rule 24 (expr -> expr INCREMENT .)
    AND             reduce using rule 24 (expr -> expr INCREMENT .)
    OR              reduce using rule 24 (expr -> expr INCREMENT .)


state 28

    (25) expr -> expr DECREMENT .

    PLUS            reduce using rule 25 (expr -> expr DECREMENT .)
    MINUS           reduce using rule 25 (expr -> expr DECREMENT .)
    TIMES           reduce using rule 25 (expr -> expr DECREMENT .)
    DIVIDE          reduce using rule 25 (expr -> expr DECREMENT .)
    MOD             reduce using rule 25 (expr -> expr DECREMENT .)
    INCREMENT       reduce using rule 25 (expr -> expr DECREMENT .)
    DECREMENT       reduce using rule 25 (expr -> expr DECREMENT .)
    END_LINE        reduce using rule 25 (expr -> expr DECREMENT .)
    WRITE           reduce using rule 25 (expr -> expr DECREMENT .)
    WHILE           reduce using rule 25 (expr -> expr DECREMENT .)
    FOR             reduce using rule 25 (expr -> expr DECREMENT .)
    IF              reduce using rule 25 (expr -> expr DECREMENT .)
    VAR             reduce using rule 25 (expr -> expr DECREMENT .)
    ID              reduce using rule 25 (expr -> expr DECREMENT .)
    NUMBER          reduce using rule 25 (expr -> expr DECREMENT .)
    STRINGS         reduce using rule 25 (expr -> expr DECREMENT .)
    TRUE            reduce using rule 25 (expr -> expr DECREMENT .)
    FALSE           reduce using rule 25 (expr -> expr DECREMENT .)
    RBRACKET        reduce using rule 25 (expr -> expr DECREMENT .)
    LT              reduce using rule 25 (expr -> expr DECREMENT .)
    LE              reduce using rule 25 (expr -> expr DECREMENT .)
    GT              reduce using rule 25 (expr -> expr DECREMENT .)
    GE              reduce using rule 25 (expr -> expr DECREMENT .)
    EQUALS          reduce using rule 25 (expr -> expr DECREMENT .)
    NE              reduce using rule 25 (expr -> expr DECREMENT .)
    $end            reduce using rule 25 (expr -> expr DECREMENT .)
    RPAREN          reduce using rule 25 (expr -> expr DECREMENT .)
    AND             reduce using rule 25 (expr -> expr DECREMENT .)
    OR              reduce using rule 25 (expr -> expr DECREMENT .)


state 29

    (20) expr -> expr MINUS . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 46

state 30

    (23) expr -> expr MOD . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 47

state 31

    (14) command -> WHILE LPAREN relexpr . RPAREN LBRACKET S RBRACKET

    RPAREN          shift and go to state 48


state 32

    (13) command -> WHILE LPAREN expr . RPAREN LBRACKET S RBRACKET
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT
    (32) relexpr -> expr . LT expr
    (33) relexpr -> expr . LE expr
    (34) relexpr -> expr . GT expr
    (35) relexpr -> expr . GE expr
    (36) relexpr -> expr . EQUALS expr
    (37) relexpr -> expr . NE expr

    RPAREN          shift and go to state 51
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 50
    GE              shift and go to state 54
    EQUALS          shift and go to state 49
    NE              shift and go to state 55


state 33

    (38) relexpr -> NOT . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 56

state 34

    (2) S -> statement END_LINE S .

    RBRACKET        reduce using rule 2 (S -> statement END_LINE S .)
    $end            reduce using rule 2 (S -> statement END_LINE S .)


state 35

    (15) command -> FOR LPAREN declarations . END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET

    END_LINE        shift and go to state 57


state 36

    (12) command -> WRITE LPAREN relexpr . RPAREN

    RPAREN          shift and go to state 58


state 37

    (11) command -> WRITE LPAREN expr . RPAREN
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT
    (32) relexpr -> expr . LT expr
    (33) relexpr -> expr . LE expr
    (34) relexpr -> expr . GT expr
    (35) relexpr -> expr . GE expr
    (36) relexpr -> expr . EQUALS expr
    (37) relexpr -> expr . NE expr

    RPAREN          shift and go to state 59
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 50
    GE              shift and go to state 54
    EQUALS          shift and go to state 49
    NE              shift and go to state 55


state 38

    (8) declarations -> VAR ID ASSIGN . expr
    (9) declarations -> VAR ID ASSIGN . relexpr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12
    NOT             shift and go to state 33

    expr                           shift and go to state 61
    relexpr                        shift and go to state 60

state 39

    (26) expr -> ID ASSIGN expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    END_LINE        reduce using rule 26 (expr -> ID ASSIGN expr .)
    WRITE           reduce using rule 26 (expr -> ID ASSIGN expr .)
    WHILE           reduce using rule 26 (expr -> ID ASSIGN expr .)
    FOR             reduce using rule 26 (expr -> ID ASSIGN expr .)
    IF              reduce using rule 26 (expr -> ID ASSIGN expr .)
    VAR             reduce using rule 26 (expr -> ID ASSIGN expr .)
    ID              reduce using rule 26 (expr -> ID ASSIGN expr .)
    NUMBER          reduce using rule 26 (expr -> ID ASSIGN expr .)
    STRINGS         reduce using rule 26 (expr -> ID ASSIGN expr .)
    TRUE            reduce using rule 26 (expr -> ID ASSIGN expr .)
    FALSE           reduce using rule 26 (expr -> ID ASSIGN expr .)
    RBRACKET        reduce using rule 26 (expr -> ID ASSIGN expr .)
    LT              reduce using rule 26 (expr -> ID ASSIGN expr .)
    LE              reduce using rule 26 (expr -> ID ASSIGN expr .)
    GT              reduce using rule 26 (expr -> ID ASSIGN expr .)
    GE              reduce using rule 26 (expr -> ID ASSIGN expr .)
    EQUALS          reduce using rule 26 (expr -> ID ASSIGN expr .)
    NE              reduce using rule 26 (expr -> ID ASSIGN expr .)
    $end            reduce using rule 26 (expr -> ID ASSIGN expr .)
    RPAREN          reduce using rule 26 (expr -> ID ASSIGN expr .)
    AND             reduce using rule 26 (expr -> ID ASSIGN expr .)
    OR              reduce using rule 26 (expr -> ID ASSIGN expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28

  ! PLUS            [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]
  ! TIMES           [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]
  ! MOD             [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]
  ! INCREMENT       [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]
  ! DECREMENT       [ reduce using rule 26 (expr -> ID ASSIGN expr .) ]


state 40

    (16) command -> IF LPAREN relexprgroup . RPAREN LBRACKET S RBRACKET
    (17) command -> IF LPAREN relexprgroup . RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> IF LPAREN relexprgroup . RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET

    RPAREN          shift and go to state 62


state 41

    (39) relexprgroup -> relexpr . AND relexprgroup
    (40) relexprgroup -> relexpr . OR relexprgroup
    (41) relexprgroup -> relexpr .

    AND             shift and go to state 63
    OR              shift and go to state 64
    RPAREN          reduce using rule 41 (relexprgroup -> relexpr .)


state 42

    (42) relexprgroup -> expr .
    (32) relexpr -> expr . LT expr
    (33) relexpr -> expr . LE expr
    (34) relexpr -> expr . GT expr
    (35) relexpr -> expr . GE expr
    (36) relexpr -> expr . EQUALS expr
    (37) relexpr -> expr . NE expr
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 42 (relexprgroup -> expr .)
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 50
    GE              shift and go to state 54
    EQUALS          shift and go to state 49
    NE              shift and go to state 55
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 43

    (22) expr -> expr DIVIDE expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    PLUS            reduce using rule 22 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 22 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 22 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 22 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 22 (expr -> expr DIVIDE expr .)
    END_LINE        reduce using rule 22 (expr -> expr DIVIDE expr .)
    WRITE           reduce using rule 22 (expr -> expr DIVIDE expr .)
    WHILE           reduce using rule 22 (expr -> expr DIVIDE expr .)
    FOR             reduce using rule 22 (expr -> expr DIVIDE expr .)
    IF              reduce using rule 22 (expr -> expr DIVIDE expr .)
    VAR             reduce using rule 22 (expr -> expr DIVIDE expr .)
    ID              reduce using rule 22 (expr -> expr DIVIDE expr .)
    NUMBER          reduce using rule 22 (expr -> expr DIVIDE expr .)
    STRINGS         reduce using rule 22 (expr -> expr DIVIDE expr .)
    TRUE            reduce using rule 22 (expr -> expr DIVIDE expr .)
    FALSE           reduce using rule 22 (expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 22 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 22 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 22 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 22 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 22 (expr -> expr DIVIDE expr .)
    EQUALS          reduce using rule 22 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 22 (expr -> expr DIVIDE expr .)
    $end            reduce using rule 22 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 22 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 22 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 22 (expr -> expr DIVIDE expr .)
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28

  ! INCREMENT       [ reduce using rule 22 (expr -> expr DIVIDE expr .) ]
  ! DECREMENT       [ reduce using rule 22 (expr -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 25 ]
  ! DIVIDE          [ shift and go to state 24 ]
  ! MOD             [ shift and go to state 30 ]


state 44

    (21) expr -> expr TIMES expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    PLUS            reduce using rule 21 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 21 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 21 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 21 (expr -> expr TIMES expr .)
    MOD             reduce using rule 21 (expr -> expr TIMES expr .)
    END_LINE        reduce using rule 21 (expr -> expr TIMES expr .)
    WRITE           reduce using rule 21 (expr -> expr TIMES expr .)
    WHILE           reduce using rule 21 (expr -> expr TIMES expr .)
    FOR             reduce using rule 21 (expr -> expr TIMES expr .)
    IF              reduce using rule 21 (expr -> expr TIMES expr .)
    VAR             reduce using rule 21 (expr -> expr TIMES expr .)
    ID              reduce using rule 21 (expr -> expr TIMES expr .)
    NUMBER          reduce using rule 21 (expr -> expr TIMES expr .)
    STRINGS         reduce using rule 21 (expr -> expr TIMES expr .)
    TRUE            reduce using rule 21 (expr -> expr TIMES expr .)
    FALSE           reduce using rule 21 (expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 21 (expr -> expr TIMES expr .)
    LT              reduce using rule 21 (expr -> expr TIMES expr .)
    LE              reduce using rule 21 (expr -> expr TIMES expr .)
    GT              reduce using rule 21 (expr -> expr TIMES expr .)
    GE              reduce using rule 21 (expr -> expr TIMES expr .)
    EQUALS          reduce using rule 21 (expr -> expr TIMES expr .)
    NE              reduce using rule 21 (expr -> expr TIMES expr .)
    $end            reduce using rule 21 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 21 (expr -> expr TIMES expr .)
    AND             reduce using rule 21 (expr -> expr TIMES expr .)
    OR              reduce using rule 21 (expr -> expr TIMES expr .)
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28

  ! INCREMENT       [ reduce using rule 21 (expr -> expr TIMES expr .) ]
  ! DECREMENT       [ reduce using rule 21 (expr -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 25 ]
  ! DIVIDE          [ shift and go to state 24 ]
  ! MOD             [ shift and go to state 30 ]


state 45

    (19) expr -> expr PLUS expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    PLUS            reduce using rule 19 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 19 (expr -> expr PLUS expr .)
    END_LINE        reduce using rule 19 (expr -> expr PLUS expr .)
    WRITE           reduce using rule 19 (expr -> expr PLUS expr .)
    WHILE           reduce using rule 19 (expr -> expr PLUS expr .)
    FOR             reduce using rule 19 (expr -> expr PLUS expr .)
    IF              reduce using rule 19 (expr -> expr PLUS expr .)
    VAR             reduce using rule 19 (expr -> expr PLUS expr .)
    ID              reduce using rule 19 (expr -> expr PLUS expr .)
    NUMBER          reduce using rule 19 (expr -> expr PLUS expr .)
    STRINGS         reduce using rule 19 (expr -> expr PLUS expr .)
    TRUE            reduce using rule 19 (expr -> expr PLUS expr .)
    FALSE           reduce using rule 19 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 19 (expr -> expr PLUS expr .)
    LT              reduce using rule 19 (expr -> expr PLUS expr .)
    LE              reduce using rule 19 (expr -> expr PLUS expr .)
    GT              reduce using rule 19 (expr -> expr PLUS expr .)
    GE              reduce using rule 19 (expr -> expr PLUS expr .)
    EQUALS          reduce using rule 19 (expr -> expr PLUS expr .)
    NE              reduce using rule 19 (expr -> expr PLUS expr .)
    $end            reduce using rule 19 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 19 (expr -> expr PLUS expr .)
    AND             reduce using rule 19 (expr -> expr PLUS expr .)
    OR              reduce using rule 19 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28

  ! TIMES           [ reduce using rule 19 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 19 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 19 (expr -> expr PLUS expr .) ]
  ! INCREMENT       [ reduce using rule 19 (expr -> expr PLUS expr .) ]
  ! DECREMENT       [ reduce using rule 19 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 29 ]


state 46

    (20) expr -> expr MINUS expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    PLUS            reduce using rule 20 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 20 (expr -> expr MINUS expr .)
    END_LINE        reduce using rule 20 (expr -> expr MINUS expr .)
    WRITE           reduce using rule 20 (expr -> expr MINUS expr .)
    WHILE           reduce using rule 20 (expr -> expr MINUS expr .)
    FOR             reduce using rule 20 (expr -> expr MINUS expr .)
    IF              reduce using rule 20 (expr -> expr MINUS expr .)
    VAR             reduce using rule 20 (expr -> expr MINUS expr .)
    ID              reduce using rule 20 (expr -> expr MINUS expr .)
    NUMBER          reduce using rule 20 (expr -> expr MINUS expr .)
    STRINGS         reduce using rule 20 (expr -> expr MINUS expr .)
    TRUE            reduce using rule 20 (expr -> expr MINUS expr .)
    FALSE           reduce using rule 20 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 20 (expr -> expr MINUS expr .)
    LT              reduce using rule 20 (expr -> expr MINUS expr .)
    LE              reduce using rule 20 (expr -> expr MINUS expr .)
    GT              reduce using rule 20 (expr -> expr MINUS expr .)
    GE              reduce using rule 20 (expr -> expr MINUS expr .)
    EQUALS          reduce using rule 20 (expr -> expr MINUS expr .)
    NE              reduce using rule 20 (expr -> expr MINUS expr .)
    $end            reduce using rule 20 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 20 (expr -> expr MINUS expr .)
    AND             reduce using rule 20 (expr -> expr MINUS expr .)
    OR              reduce using rule 20 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28

  ! TIMES           [ reduce using rule 20 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 20 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 20 (expr -> expr MINUS expr .) ]
  ! INCREMENT       [ reduce using rule 20 (expr -> expr MINUS expr .) ]
  ! DECREMENT       [ reduce using rule 20 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 29 ]


state 47

    (23) expr -> expr MOD expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    PLUS            reduce using rule 23 (expr -> expr MOD expr .)
    MINUS           reduce using rule 23 (expr -> expr MOD expr .)
    TIMES           reduce using rule 23 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 23 (expr -> expr MOD expr .)
    MOD             reduce using rule 23 (expr -> expr MOD expr .)
    END_LINE        reduce using rule 23 (expr -> expr MOD expr .)
    WRITE           reduce using rule 23 (expr -> expr MOD expr .)
    WHILE           reduce using rule 23 (expr -> expr MOD expr .)
    FOR             reduce using rule 23 (expr -> expr MOD expr .)
    IF              reduce using rule 23 (expr -> expr MOD expr .)
    VAR             reduce using rule 23 (expr -> expr MOD expr .)
    ID              reduce using rule 23 (expr -> expr MOD expr .)
    NUMBER          reduce using rule 23 (expr -> expr MOD expr .)
    STRINGS         reduce using rule 23 (expr -> expr MOD expr .)
    TRUE            reduce using rule 23 (expr -> expr MOD expr .)
    FALSE           reduce using rule 23 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 23 (expr -> expr MOD expr .)
    LT              reduce using rule 23 (expr -> expr MOD expr .)
    LE              reduce using rule 23 (expr -> expr MOD expr .)
    GT              reduce using rule 23 (expr -> expr MOD expr .)
    GE              reduce using rule 23 (expr -> expr MOD expr .)
    EQUALS          reduce using rule 23 (expr -> expr MOD expr .)
    NE              reduce using rule 23 (expr -> expr MOD expr .)
    $end            reduce using rule 23 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 23 (expr -> expr MOD expr .)
    AND             reduce using rule 23 (expr -> expr MOD expr .)
    OR              reduce using rule 23 (expr -> expr MOD expr .)
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28

  ! INCREMENT       [ reduce using rule 23 (expr -> expr MOD expr .) ]
  ! DECREMENT       [ reduce using rule 23 (expr -> expr MOD expr .) ]
  ! PLUS            [ shift and go to state 26 ]
  ! MINUS           [ shift and go to state 29 ]
  ! TIMES           [ shift and go to state 25 ]
  ! DIVIDE          [ shift and go to state 24 ]
  ! MOD             [ shift and go to state 30 ]


state 48

    (14) command -> WHILE LPAREN relexpr RPAREN . LBRACKET S RBRACKET

    LBRACKET        shift and go to state 65


state 49

    (36) relexpr -> expr EQUALS . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 66

state 50

    (34) relexpr -> expr GT . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 67

state 51

    (13) command -> WHILE LPAREN expr RPAREN . LBRACKET S RBRACKET

    LBRACKET        shift and go to state 68


state 52

    (32) relexpr -> expr LT . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 69

state 53

    (33) relexpr -> expr LE . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 70

state 54

    (35) relexpr -> expr GE . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 71

state 55

    (37) relexpr -> expr NE . expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 72

state 56

    (38) relexpr -> NOT expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 38 (relexpr -> NOT expr .)
    AND             reduce using rule 38 (relexpr -> NOT expr .)
    OR              reduce using rule 38 (relexpr -> NOT expr .)
    END_LINE        reduce using rule 38 (relexpr -> NOT expr .)
    WRITE           reduce using rule 38 (relexpr -> NOT expr .)
    WHILE           reduce using rule 38 (relexpr -> NOT expr .)
    FOR             reduce using rule 38 (relexpr -> NOT expr .)
    IF              reduce using rule 38 (relexpr -> NOT expr .)
    VAR             reduce using rule 38 (relexpr -> NOT expr .)
    ID              reduce using rule 38 (relexpr -> NOT expr .)
    NUMBER          reduce using rule 38 (relexpr -> NOT expr .)
    STRINGS         reduce using rule 38 (relexpr -> NOT expr .)
    TRUE            reduce using rule 38 (relexpr -> NOT expr .)
    FALSE           reduce using rule 38 (relexpr -> NOT expr .)
    $end            reduce using rule 38 (relexpr -> NOT expr .)
    RBRACKET        reduce using rule 38 (relexpr -> NOT expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 57

    (15) command -> FOR LPAREN declarations END_LINE . relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    NOT             shift and go to state 33
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    relexpr                        shift and go to state 73
    expr                           shift and go to state 74

state 58

    (12) command -> WRITE LPAREN relexpr RPAREN .

    END_LINE        reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    WRITE           reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    WHILE           reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    FOR             reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    IF              reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    VAR             reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    ID              reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    NUMBER          reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    STRINGS         reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    TRUE            reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    FALSE           reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    RBRACKET        reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)
    $end            reduce using rule 12 (command -> WRITE LPAREN relexpr RPAREN .)


state 59

    (11) command -> WRITE LPAREN expr RPAREN .

    END_LINE        reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    WRITE           reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    WHILE           reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    FOR             reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    IF              reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    VAR             reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    ID              reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    NUMBER          reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    STRINGS         reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    TRUE            reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    FALSE           reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)
    $end            reduce using rule 11 (command -> WRITE LPAREN expr RPAREN .)


state 60

    (9) declarations -> VAR ID ASSIGN relexpr .

    END_LINE        reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    WRITE           reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    WHILE           reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    FOR             reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    IF              reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    VAR             reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    ID              reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    NUMBER          reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    STRINGS         reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    TRUE            reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    FALSE           reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    RBRACKET        reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)
    $end            reduce using rule 9 (declarations -> VAR ID ASSIGN relexpr .)


state 61

    (8) declarations -> VAR ID ASSIGN expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT
    (32) relexpr -> expr . LT expr
    (33) relexpr -> expr . LE expr
    (34) relexpr -> expr . GT expr
    (35) relexpr -> expr . GE expr
    (36) relexpr -> expr . EQUALS expr
    (37) relexpr -> expr . NE expr

    END_LINE        reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    WRITE           reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    WHILE           reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    FOR             reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    IF              reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    VAR             reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    ID              reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    NUMBER          reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    STRINGS         reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    TRUE            reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    FALSE           reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    RBRACKET        reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    $end            reduce using rule 8 (declarations -> VAR ID ASSIGN expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28
    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 50
    GE              shift and go to state 54
    EQUALS          shift and go to state 49
    NE              shift and go to state 55


state 62

    (16) command -> IF LPAREN relexprgroup RPAREN . LBRACKET S RBRACKET
    (17) command -> IF LPAREN relexprgroup RPAREN . LBRACKET S RBRACKET ELSE command
    (18) command -> IF LPAREN relexprgroup RPAREN . LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET

    LBRACKET        shift and go to state 75


state 63

    (39) relexprgroup -> relexpr AND . relexprgroup
    (39) relexprgroup -> . relexpr AND relexprgroup
    (40) relexprgroup -> . relexpr OR relexprgroup
    (41) relexprgroup -> . relexpr
    (42) relexprgroup -> . expr
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    NOT             shift and go to state 33
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    relexprgroup                   shift and go to state 76
    relexpr                        shift and go to state 41
    expr                           shift and go to state 42

state 64

    (40) relexprgroup -> relexpr OR . relexprgroup
    (39) relexprgroup -> . relexpr AND relexprgroup
    (40) relexprgroup -> . relexpr OR relexprgroup
    (41) relexprgroup -> . relexpr
    (42) relexprgroup -> . expr
    (32) relexpr -> . expr LT expr
    (33) relexpr -> . expr LE expr
    (34) relexpr -> . expr GT expr
    (35) relexpr -> . expr GE expr
    (36) relexpr -> . expr EQUALS expr
    (37) relexpr -> . expr NE expr
    (38) relexpr -> . NOT expr
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    NOT             shift and go to state 33
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    relexprgroup                   shift and go to state 77
    relexpr                        shift and go to state 41
    expr                           shift and go to state 42

state 65

    (14) command -> WHILE LPAREN relexpr RPAREN LBRACKET . S RBRACKET
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 78
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 66

    (36) relexpr -> expr EQUALS expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 36 (relexpr -> expr EQUALS expr .)
    AND             reduce using rule 36 (relexpr -> expr EQUALS expr .)
    OR              reduce using rule 36 (relexpr -> expr EQUALS expr .)
    END_LINE        reduce using rule 36 (relexpr -> expr EQUALS expr .)
    WRITE           reduce using rule 36 (relexpr -> expr EQUALS expr .)
    WHILE           reduce using rule 36 (relexpr -> expr EQUALS expr .)
    FOR             reduce using rule 36 (relexpr -> expr EQUALS expr .)
    IF              reduce using rule 36 (relexpr -> expr EQUALS expr .)
    VAR             reduce using rule 36 (relexpr -> expr EQUALS expr .)
    ID              reduce using rule 36 (relexpr -> expr EQUALS expr .)
    NUMBER          reduce using rule 36 (relexpr -> expr EQUALS expr .)
    STRINGS         reduce using rule 36 (relexpr -> expr EQUALS expr .)
    TRUE            reduce using rule 36 (relexpr -> expr EQUALS expr .)
    FALSE           reduce using rule 36 (relexpr -> expr EQUALS expr .)
    $end            reduce using rule 36 (relexpr -> expr EQUALS expr .)
    RBRACKET        reduce using rule 36 (relexpr -> expr EQUALS expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 67

    (34) relexpr -> expr GT expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 34 (relexpr -> expr GT expr .)
    AND             reduce using rule 34 (relexpr -> expr GT expr .)
    OR              reduce using rule 34 (relexpr -> expr GT expr .)
    END_LINE        reduce using rule 34 (relexpr -> expr GT expr .)
    WRITE           reduce using rule 34 (relexpr -> expr GT expr .)
    WHILE           reduce using rule 34 (relexpr -> expr GT expr .)
    FOR             reduce using rule 34 (relexpr -> expr GT expr .)
    IF              reduce using rule 34 (relexpr -> expr GT expr .)
    VAR             reduce using rule 34 (relexpr -> expr GT expr .)
    ID              reduce using rule 34 (relexpr -> expr GT expr .)
    NUMBER          reduce using rule 34 (relexpr -> expr GT expr .)
    STRINGS         reduce using rule 34 (relexpr -> expr GT expr .)
    TRUE            reduce using rule 34 (relexpr -> expr GT expr .)
    FALSE           reduce using rule 34 (relexpr -> expr GT expr .)
    $end            reduce using rule 34 (relexpr -> expr GT expr .)
    RBRACKET        reduce using rule 34 (relexpr -> expr GT expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 68

    (13) command -> WHILE LPAREN expr RPAREN LBRACKET . S RBRACKET
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 79
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 69

    (32) relexpr -> expr LT expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 32 (relexpr -> expr LT expr .)
    AND             reduce using rule 32 (relexpr -> expr LT expr .)
    OR              reduce using rule 32 (relexpr -> expr LT expr .)
    END_LINE        reduce using rule 32 (relexpr -> expr LT expr .)
    WRITE           reduce using rule 32 (relexpr -> expr LT expr .)
    WHILE           reduce using rule 32 (relexpr -> expr LT expr .)
    FOR             reduce using rule 32 (relexpr -> expr LT expr .)
    IF              reduce using rule 32 (relexpr -> expr LT expr .)
    VAR             reduce using rule 32 (relexpr -> expr LT expr .)
    ID              reduce using rule 32 (relexpr -> expr LT expr .)
    NUMBER          reduce using rule 32 (relexpr -> expr LT expr .)
    STRINGS         reduce using rule 32 (relexpr -> expr LT expr .)
    TRUE            reduce using rule 32 (relexpr -> expr LT expr .)
    FALSE           reduce using rule 32 (relexpr -> expr LT expr .)
    $end            reduce using rule 32 (relexpr -> expr LT expr .)
    RBRACKET        reduce using rule 32 (relexpr -> expr LT expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 70

    (33) relexpr -> expr LE expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 33 (relexpr -> expr LE expr .)
    AND             reduce using rule 33 (relexpr -> expr LE expr .)
    OR              reduce using rule 33 (relexpr -> expr LE expr .)
    END_LINE        reduce using rule 33 (relexpr -> expr LE expr .)
    WRITE           reduce using rule 33 (relexpr -> expr LE expr .)
    WHILE           reduce using rule 33 (relexpr -> expr LE expr .)
    FOR             reduce using rule 33 (relexpr -> expr LE expr .)
    IF              reduce using rule 33 (relexpr -> expr LE expr .)
    VAR             reduce using rule 33 (relexpr -> expr LE expr .)
    ID              reduce using rule 33 (relexpr -> expr LE expr .)
    NUMBER          reduce using rule 33 (relexpr -> expr LE expr .)
    STRINGS         reduce using rule 33 (relexpr -> expr LE expr .)
    TRUE            reduce using rule 33 (relexpr -> expr LE expr .)
    FALSE           reduce using rule 33 (relexpr -> expr LE expr .)
    $end            reduce using rule 33 (relexpr -> expr LE expr .)
    RBRACKET        reduce using rule 33 (relexpr -> expr LE expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 71

    (35) relexpr -> expr GE expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 35 (relexpr -> expr GE expr .)
    AND             reduce using rule 35 (relexpr -> expr GE expr .)
    OR              reduce using rule 35 (relexpr -> expr GE expr .)
    END_LINE        reduce using rule 35 (relexpr -> expr GE expr .)
    WRITE           reduce using rule 35 (relexpr -> expr GE expr .)
    WHILE           reduce using rule 35 (relexpr -> expr GE expr .)
    FOR             reduce using rule 35 (relexpr -> expr GE expr .)
    IF              reduce using rule 35 (relexpr -> expr GE expr .)
    VAR             reduce using rule 35 (relexpr -> expr GE expr .)
    ID              reduce using rule 35 (relexpr -> expr GE expr .)
    NUMBER          reduce using rule 35 (relexpr -> expr GE expr .)
    STRINGS         reduce using rule 35 (relexpr -> expr GE expr .)
    TRUE            reduce using rule 35 (relexpr -> expr GE expr .)
    FALSE           reduce using rule 35 (relexpr -> expr GE expr .)
    $end            reduce using rule 35 (relexpr -> expr GE expr .)
    RBRACKET        reduce using rule 35 (relexpr -> expr GE expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 72

    (37) relexpr -> expr NE expr .
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          reduce using rule 37 (relexpr -> expr NE expr .)
    AND             reduce using rule 37 (relexpr -> expr NE expr .)
    OR              reduce using rule 37 (relexpr -> expr NE expr .)
    END_LINE        reduce using rule 37 (relexpr -> expr NE expr .)
    WRITE           reduce using rule 37 (relexpr -> expr NE expr .)
    WHILE           reduce using rule 37 (relexpr -> expr NE expr .)
    FOR             reduce using rule 37 (relexpr -> expr NE expr .)
    IF              reduce using rule 37 (relexpr -> expr NE expr .)
    VAR             reduce using rule 37 (relexpr -> expr NE expr .)
    ID              reduce using rule 37 (relexpr -> expr NE expr .)
    NUMBER          reduce using rule 37 (relexpr -> expr NE expr .)
    STRINGS         reduce using rule 37 (relexpr -> expr NE expr .)
    TRUE            reduce using rule 37 (relexpr -> expr NE expr .)
    FALSE           reduce using rule 37 (relexpr -> expr NE expr .)
    $end            reduce using rule 37 (relexpr -> expr NE expr .)
    RBRACKET        reduce using rule 37 (relexpr -> expr NE expr .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 73

    (15) command -> FOR LPAREN declarations END_LINE relexpr . END_LINE expr RPAREN LBRACKET S RBRACKET

    END_LINE        shift and go to state 80


state 74

    (32) relexpr -> expr . LT expr
    (33) relexpr -> expr . LE expr
    (34) relexpr -> expr . GT expr
    (35) relexpr -> expr . GE expr
    (36) relexpr -> expr . EQUALS expr
    (37) relexpr -> expr . NE expr
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    LT              shift and go to state 52
    LE              shift and go to state 53
    GT              shift and go to state 50
    GE              shift and go to state 54
    EQUALS          shift and go to state 49
    NE              shift and go to state 55
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 75

    (16) command -> IF LPAREN relexprgroup RPAREN LBRACKET . S RBRACKET
    (17) command -> IF LPAREN relexprgroup RPAREN LBRACKET . S RBRACKET ELSE command
    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET . S RBRACKET ELSE LBRACKET S RBRACKET
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 81
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 76

    (39) relexprgroup -> relexpr AND relexprgroup .

    RPAREN          reduce using rule 39 (relexprgroup -> relexpr AND relexprgroup .)


state 77

    (40) relexprgroup -> relexpr OR relexprgroup .

    RPAREN          reduce using rule 40 (relexprgroup -> relexpr OR relexprgroup .)


state 78

    (14) command -> WHILE LPAREN relexpr RPAREN LBRACKET S . RBRACKET

    RBRACKET        shift and go to state 82


state 79

    (13) command -> WHILE LPAREN expr RPAREN LBRACKET S . RBRACKET

    RBRACKET        shift and go to state 83


state 80

    (15) command -> FOR LPAREN declarations END_LINE relexpr END_LINE . expr RPAREN LBRACKET S RBRACKET
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 84

state 81

    (16) command -> IF LPAREN relexprgroup RPAREN LBRACKET S . RBRACKET
    (17) command -> IF LPAREN relexprgroup RPAREN LBRACKET S . RBRACKET ELSE command
    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET S . RBRACKET ELSE LBRACKET S RBRACKET

    RBRACKET        shift and go to state 85


state 82

    (14) command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .

    END_LINE        reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    WRITE           reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    WHILE           reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    FOR             reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    IF              reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    VAR             reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    ID              reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    NUMBER          reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    STRINGS         reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    TRUE            reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    FALSE           reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    RBRACKET        reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)
    $end            reduce using rule 14 (command -> WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET .)


state 83

    (13) command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .

    END_LINE        reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    WRITE           reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    WHILE           reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    FOR             reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    IF              reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    VAR             reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    ID              reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    NUMBER          reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    STRINGS         reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    TRUE            reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    FALSE           reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    RBRACKET        reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)
    $end            reduce using rule 13 (command -> WHILE LPAREN expr RPAREN LBRACKET S RBRACKET .)


state 84

    (15) command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr . RPAREN LBRACKET S RBRACKET
    (19) expr -> expr . PLUS expr
    (20) expr -> expr . MINUS expr
    (21) expr -> expr . TIMES expr
    (22) expr -> expr . DIVIDE expr
    (23) expr -> expr . MOD expr
    (24) expr -> expr . INCREMENT
    (25) expr -> expr . DECREMENT

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 26
    MINUS           shift and go to state 29
    TIMES           shift and go to state 25
    DIVIDE          shift and go to state 24
    MOD             shift and go to state 30
    INCREMENT       shift and go to state 27
    DECREMENT       shift and go to state 28


state 85

    (16) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .
    (17) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET . ELSE command
    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET . ELSE LBRACKET S RBRACKET

    END_LINE        reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    WRITE           reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    WHILE           reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    FOR             reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    IF              reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    VAR             reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    ID              reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    NUMBER          reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    STRINGS         reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    TRUE            reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    FALSE           reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    RBRACKET        reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    $end            reduce using rule 16 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET .)
    ELSE            shift and go to state 87


state 86

    (15) command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN . LBRACKET S RBRACKET

    LBRACKET        shift and go to state 88


state 87

    (17) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE . command
    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE . LBRACKET S RBRACKET
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET

    LBRACKET        shift and go to state 89
    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11

    command                        shift and go to state 90

state 88

    (15) command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET . S RBRACKET
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 91
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 89

    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET . S RBRACKET
    (1) S -> . statement S
    (2) S -> . statement END_LINE S
    (3) S -> . statement END_LINE
    (4) S -> . statement
    (5) statement -> . command
    (6) statement -> . declarations
    (7) statement -> . expr
    (11) command -> . WRITE LPAREN expr RPAREN
    (12) command -> . WRITE LPAREN relexpr RPAREN
    (13) command -> . WHILE LPAREN expr RPAREN LBRACKET S RBRACKET
    (14) command -> . WHILE LPAREN relexpr RPAREN LBRACKET S RBRACKET
    (15) command -> . FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET
    (16) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET
    (17) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command
    (18) command -> . IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET
    (8) declarations -> . VAR ID ASSIGN expr
    (9) declarations -> . VAR ID ASSIGN relexpr
    (10) declarations -> . VAR ID
    (19) expr -> . expr PLUS expr
    (20) expr -> . expr MINUS expr
    (21) expr -> . expr TIMES expr
    (22) expr -> . expr DIVIDE expr
    (23) expr -> . expr MOD expr
    (24) expr -> . expr INCREMENT
    (25) expr -> . expr DECREMENT
    (26) expr -> . ID ASSIGN expr
    (27) expr -> . NUMBER
    (28) expr -> . STRINGS
    (29) expr -> . ID
    (30) expr -> . TRUE
    (31) expr -> . FALSE

    WRITE           shift and go to state 7
    WHILE           shift and go to state 2
    FOR             shift and go to state 6
    IF              shift and go to state 11
    VAR             shift and go to state 9
    ID              shift and go to state 10
    NUMBER          shift and go to state 1
    STRINGS         shift and go to state 4
    TRUE            shift and go to state 3
    FALSE           shift and go to state 12

    expr                           shift and go to state 13
    declarations                   shift and go to state 14
    S                              shift and go to state 92
    command                        shift and go to state 15
    statement                      shift and go to state 5

state 90

    (17) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .

    END_LINE        reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    WRITE           reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    WHILE           reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    FOR             reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    IF              reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    VAR             reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    ID              reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    NUMBER          reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    STRINGS         reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    TRUE            reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    FALSE           reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    RBRACKET        reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)
    $end            reduce using rule 17 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE command .)


state 91

    (15) command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S . RBRACKET

    RBRACKET        shift and go to state 93


state 92

    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S . RBRACKET

    RBRACKET        shift and go to state 94


state 93

    (15) command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .

    END_LINE        reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    WRITE           reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    WHILE           reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    FOR             reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    IF              reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    VAR             reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    ID              reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    NUMBER          reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    STRINGS         reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    TRUE            reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    FALSE           reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    RBRACKET        reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)
    $end            reduce using rule 15 (command -> FOR LPAREN declarations END_LINE relexpr END_LINE expr RPAREN LBRACKET S RBRACKET .)


state 94

    (18) command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .

    END_LINE        reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    WRITE           reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    WHILE           reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    FOR             reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    IF              reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    VAR             reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    ID              reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    NUMBER          reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    STRINGS         reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    TRUE            reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    FALSE           reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    RBRACKET        reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)
    $end            reduce using rule 18 (command -> IF LPAREN relexprgroup RPAREN LBRACKET S RBRACKET ELSE LBRACKET S RBRACKET .)

